"""Miscellaneous functions to analyze the simulation results.

Index
-----
.. currentmodule:: nac.analysis.tools
.. autosummary::

API
---

"""

import os
from typing import Tuple

import numpy as np
import pyparsing as pa
from scipy.optimize import curve_fit

from ..common import fs_to_cm, h2ev, hbar, r2meV


def autocorrelate(f: np.ndarray) -> Tuple[float, float]:
    """Compute the un-normalized and normalized autocorrelation of a function."""
    d_f = f - f.mean()
    # Compute the autocorrelation function
    uacf = np.correlate(d_f, d_f, "full")[-d_f.size:] / d_f.size
    # Compute the normalized autocorrelation function
    nacf = uacf / uacf[0]
    return uacf, nacf


def gauss_function(x: float, sigma: float) -> np.ndarray:
    """Compute a Gaussian function used to fit the dephasing time."""
    return np.exp(-0.5 * (-x / sigma) ** 2)


def func_conv(x_real: np.ndarray, x_grid: np.ndarray, delta: float) -> np.ndarray:
    """Compute a convolution on a grid using a Gaussian function."""
    return np.exp(-2 * (x_grid - x_real) ** 2 / delta ** 2)


def convolute(x: np.ndarray, y: np.ndarray, x_points: np.ndarray, sigma: float) -> np.ndarray:
    """Convolute a spectrum on a grid of x_points.

    You need as input x, y and the grid where to convolute.
    """
    # Compute gaussian prefactor
    prefactor = np.sqrt(2.0) / (sigma * np.sqrt(np.pi))
    # Convolute spectrum over grid
    y_points = prefactor * np.stack(
        np.sum(y * func_conv(x, x_point, sigma)) for x_point in x_points)
    return y_points


def dephasing(f: np.ndarray, dt: float):
    """Compute the dephasing time of a given function.

    Use the optical response formalisms:
    S. Mukamel, Principles of Nonlinear Optical Spectroscopy, 1995
    About the implementation we use the 2nd order cumulant expansion.
    See also eq. (2) in : Kilina et al. Phys. Rev. Lett., 110, 180404, (2013)
    To calculate the dephasing time tau we fit the dephasing function to a
    gaussian of the type : exp(-0.5 * (-x / tau) ** 2)
    """
    # Conversion of hbar to hartree * fs
    hbar_au = hbar / h2ev
    ts = np.arange(f.shape[0]) * dt
    cumu_ii = np.stack(np.sum(f[0:i]) for i in range(ts.size)) * dt / hbar_au
    cumu_i = np.stack(np.sum(cumu_ii[0:i])
                      for i in range(ts.size)) * dt / hbar_au
    deph = np.exp(-cumu_i)
    np.seterr(over='ignore')
    popt = curve_fit(gauss_function, ts, deph)[0]
    xs = np.exp(-0.5 * (-ts / popt[0]) ** 2)
    deph = np.column_stack((deph, xs))
    deph_time = popt[0]  # in fs
    line_broadening = hbar / deph_time  # in eV
    return deph, deph_time, line_broadening


def spectral_density(f, dt):
    """Fourier Transform of a given function f using a dense grid with 100000 points.

    In the case of a FFT of a normalized autocorrelation function,
    this corresponds to a spectral density
    """
    f_fft = abs(1 / np.sqrt(2 * np.pi) * np.fft.fft(f, 100000) * dt) ** 2
    # Fourier Transform of the time axis
    freq = np.fft.fftfreq(len(f_fft), dt)
    # Conversion of the x axis (given in cycles/fs) to cm-1
    freq = freq * fs_to_cm
    return f_fft, freq


def read_couplings(path_hams, ts):
    """Read the non adiabatic coupling vectors from the files generated for the NAMD simulations."""
    files_im = [os.path.join(path_hams, f'Ham_{i}_im')
                for i in range(ts)]
    xs = np.stack(np.loadtxt(fn) for fn in files_im)
    return xs * r2meV  # return energies in meV


def read_energies(path_hams, ts):
    """Read the molecular orbital energies of each state.

    The target files are generated for the NAMD simulations.
    """
    files_re = [os.path.join(path_hams, f'Ham_{i}_re')
                for i in range(ts)]
    xs = np.stack(np.diag(np.loadtxt(fn)) for fn in files_re)
    return xs * r2meV / 1000  # return energies in eV


def read_energies_pyxaid(path, fn, nstates, nconds):
    """Read the molecular orbital energies of each state from the output files generated by PYXAID."""
    inpfile = os.path.join(path, fn)
    cols = tuple(range(5, nstates * 2 + 5, 2))
    xs = np.stack(np.loadtxt(f'{inpfile}{j}', usecols=cols)
                  for j in range(nconds)).transpose()
    # Rows = timeframes ; Columns = states ; tensor = initial conditions
    xs = xs.swapaxes(0, 1)
    return xs


def read_pops_pyxaid(path, fn, nstates, nconds):
    """Read the population of each state from the output files generated by PYXAID."""
    inpfile = os.path.join(path, fn)
    cols = tuple(range(3, nstates * 2 + 3, 2))
    xs = np.stack(np.loadtxt(f'{inpfile}{j}', usecols=cols)
                  for j in range(nconds)).transpose()
    # Rows = timeframes ; Columns = states ; tensor = initial conditions
    xs = xs.swapaxes(0, 1)
    return xs


def parse_list_of_lists(xs: list):
    """Parse a list of list of integers using pyparsing."""
    enclosed = pa.Forward()  # Parser to be defined later
    natural = pa.Word(pa.nums)  # Natural Number
    # Nested Grammar
    nestedBrackets = pa.nestedExpr(pa.Suppress(
        '['), pa.Suppress(']'), content=enclosed)
    enclosed << (natural | pa.Suppress(',') | nestedBrackets)
    try:
        rs = enclosed.parseString(xs).asList()[0]
        return list(map(lambda x: list(map(int, x)), rs))
    except pa.ParseException:
        raise RuntimeError("Invalid Macro states Specification")
